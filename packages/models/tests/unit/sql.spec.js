import analyze from '../../src/sql/analyze';
import normalize from '../../src/sql/normalize';
import parse from '../../src/sql/parse';

describe('parse SQL', () => {
  test('produces a parse tree', () => {
    expect(
      parse(
        `SELECT users.*, a.* FROM users JOIN addresses a ON a.user_id = users.id`
      )
    ).toEqual({
      type: 'statement',
      variant: 'list',
      statement: [
        {
          type: 'statement',
          variant: 'select',
          result: [
            { type: 'identifier', variant: 'star', name: 'users.*' },
            { type: 'identifier', variant: 'star', name: 'a.*' },
          ],
          from: {
            type: 'map',
            variant: 'join',
            source: { type: 'identifier', variant: 'table', name: 'users' },
            map: [
              {
                type: 'join',
                variant: 'join',
                source: {
                  type: 'identifier',
                  variant: 'table',
                  name: 'addresses',
                  alias: 'a',
                },
                constraint: {
                  type: 'constraint',
                  variant: 'join',
                  format: 'on',
                  on: {
                    type: 'expression',
                    format: 'binary',
                    variant: 'operation',
                    operation: '=',
                    left: {
                      type: 'identifier',
                      variant: 'column',
                      name: 'a.user_id',
                    },
                    right: {
                      type: 'identifier',
                      variant: 'column',
                      name: 'users.id',
                    },
                  },
                },
              },
            ],
          },
        },
      ],
    });
  });

  test('reports a parse error', () => {
    let err;
    expect(
      parse(
        `SELECT users.*, a.* JOIN addresses a ON a.user_id = users.id`,
        (error) => {
          err = error;
        }
      )
    ).toBeNull();
    expect(err.toString()).toEqual(
      `Syntax error found near Star (SELECT Results Clause): SELECT users.*, a.* JOIN addresses a ON a.user_id = users.id`
    );
  });
});

describe('normalize SQL', () => {
  test('removes literals', () => {
    expect(
      normalize(`SELECT users.*, a.* FROM users WHERE a.user_id = 'alice'`)
    ).toEqual(`SELECT users.*, a.* FROM users WHERE a.user_id = ?`);
  });

  test('removes comments correctly', () => {
    expect(
      normalize(
        `SELECT 4 AS random; -- guaranteed random, generated by fair dice roll`
      )
    ).toEqual(`SELECT ? AS random; `);
  });

  test('handles comments in strings', () => {
    expect(normalize(`SELECT 'hello -- world' AS title`)).toEqual(
      `SELECT ? AS title`
    );
  });

  test('handles backslashes and escapes in strings correctly', () => {
    expect(normalize("SELECT '''hello world''' AS quoted")).toEqual(
      'SELECT ? AS quoted'
    );
    expect(normalize("SELECT '\\' AS backslash")).toEqual(
      'SELECT ? AS backslash'
    );
  });

  // TODO: I would prefer if the whitespace was collapsed, but it's OK for now.
  test('handles comments embedded in multiline SQL', () => {
    expect(
      normalize(`SELECT *
-- this table contains users
FROM users`)
    ).toEqual(`SELECT *

FROM users`);
  });
});

describe('analyze SQL', () => {
  test('extracts key SQL features', () => {
    expect(
      analyze(
        `SELECT users.*, a.* FROM users JOIN addresses a ON a.user_id = ?`
      )
    ).toEqual({
      actions: ['select'],
      columns: ['a.*', 'a.user_id', 'users.*'],
      joinCount: 1,
      tables: ['addresses', 'users'],
    });
  });
});
