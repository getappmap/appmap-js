import { join } from 'path';

import { existsSync, promises as fsp, statSync } from 'fs';
import { queue } from 'async';
import { glob } from 'glob';
import yaml from 'js-yaml';
import { OpenAPIV3 } from 'openapi-types';
import {
  Model,
  parseHTTPServerRequests,
  rpcRequestForEvent,
  SecuritySchemes,
  verbose,
} from '@appland/openapi';
import { Event } from '@appland/models';
import { Arguments, Argv } from 'yargs';
import { inspect } from 'util';

class OpenAPICommand {
  private readonly model = new Model();
  private readonly securitySchemes = new SecuritySchemes();

  public errors: string[] = [];

  constructor(private readonly appmapDir: string) {}

  async execute(): Promise<{
    paths: OpenAPIV3.PathsObject;
    securitySchemes: Record<string, OpenAPIV3.SecuritySchemeObject>;
  }> {
    const q = queue(this.collectAppMap.bind(this), 5);
    q.pause();

    // Make sure the directory exists -- if it doesn't, the glob below just returns nothing.
    if (!existsSync(this.appmapDir)) {
      throw new Error(`AppMap directory ${this.appmapDir} does not exist`);
    }

    const files = glob.sync(join(this.appmapDir, '**', '*.appmap.json'));
    files.forEach((f) => q.push(f));
    await new Promise<void>((resolve, reject) => {
      q.drain(resolve);
      q.error(reject);
      q.resume();
    });

    return {
      paths: this.model.openapi(),
      securitySchemes: this.securitySchemes.openapi(),
    };
  }

  async collectAppMap(file: string): Promise<void> {
    try {
      const data = await fsp.readFile(file, 'utf-8');
      parseHTTPServerRequests(JSON.parse(data), (e: Event) => {
        const request = rpcRequestForEvent(e);
        if (request) {
          this.model.addRpcRequest(request);
          this.securitySchemes.addRpcRequest(request);
        }
      });
    } catch (e) {
      // Re-throwing this error crashes the whole process.
      // So if these is a malformed AppMap, indicate it here but don't blow everything up.
      // Do not write to stdout!
      let errorString: string;
      try {
        errorString = inspect(e);
      } catch (x) {
        errorString = ((e as any) || '').toString();
      }
      this.errors.push(errorString);
    }
  }
}

async function loadTemplate(fileName: string): Promise<any> {
  if (!fileName) {
    // eslint-disable-next-line no-param-reassign
    fileName = join(__dirname, '../../resources/openapi-template.yaml');
  }
  return yaml.load((await fsp.readFile(fileName)).toString());
}

export default {
  command: 'openapi',
  OpenAPICommand,
  aliases: ['swagger'],
  describe: 'Generate OpenAPI from AppMaps in a directory',
  builder(args: Argv) {
    args.option('directory', {
      describe: 'program working directory',
      type: 'string',
      alias: 'd',
    });
    args.option('appmap-dir', {
      describe: 'directory to recursively inspect for AppMaps',
    });
    args.option('output-file', {
      alias: ['o'],
      describe: 'output file name',
      requiresArg: true,
    });
    args.option('openapi-template', {
      describe:
        'template YAML; generated content will be placed in the paths and components sections',
    });
    args.option('openapi-title', {
      describe: 'info/title field of the OpenAPI document',
    });
    args.option('openapi-version', {
      describe: 'info/version field of the OpenAPI document',
    });
    return args.strict();
  },
  async handler(argv: Arguments | any) {
    verbose(argv.verbose);
    handleWorkingDirectory(argv.directory);

    const { openapiTitle, openapiVersion } = argv;

    function tryConfigure(path: string, fn: () => void) {
      try {
        fn();
      } catch {
        console.warn(`Warning: unable to configure OpenAPI field ${path}`);
      }
    }
    const appmapDir = await locateAppMapDir(argv.appmapDir);

    const cmd = new OpenAPICommand(appmapDir);
    const openapi = await cmd.execute();

    const template = await loadTemplate(argv.openapiTemplate);
    template.paths = openapi.paths;

    // TODO: This should be made available, but isn't
    template.components = (openapi as any).components;

    for (const error of cmd.errors) {
      console.warn(error);
    }

    if (openapiTitle) {
      tryConfigure('info.title', () => {
        template.info.title = openapiTitle;
      });
    }
    if (openapiVersion) {
      tryConfigure('info.version', () => {
        template.info.version = openapiVersion;
      });
    }

    const fileContents = `# Generated by: @appland/appmap openapi
#
# Customize the title with: --openapi-title
# Customize the version with: --openapi-version
# Customize this entire template with: --openapi-template
#
# 'paths' and 'components' will be populated automatically.
${yaml.dump(template)}
`;
    if (argv.outputFile) {
      await fsp.writeFile(argv.outputFile, fileContents);
    } else {
      console.log(fileContents);
    }
  },
};
